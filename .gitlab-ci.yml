stages:
  - test
  - delivery
  - deploy

variables:
  IMAGE_TAG: "snapshot"

workflow:
  rules:
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event"'
      variables:
        IMAGE_TAG: merge-$CI_MERGE_REQUEST_ID
        KADOK_ENV: staging
    - if: '$CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH'
      variables:
        IMAGE_TAG: $CI_COMMIT_SHORT_SHA
        KADOK_ENV: production
    - when: never

test_code:
  stage: test
  image: golang:1.17
  rules:
    - changes:
      - "**/*.go"
      - "*.go"
      - go.mod
      - go.sum
  script:
    - go install github.com/t-yuki/gocover-cobertura@latest
    - go install github.com/jstemmer/go-junit-report@latest
    - go install github.com/kyoh86/richgo@latest
    - >
      go test -v -cover -covermode="count"
      -coverprofile=coverage.txt ./... |
      bash -c 'tee >(RICHGO_FORCE_COLOR=1 richgo testfilter > /dev/stderr)' |
      go-junit-report -set-exit-code > junit.xml
    - go tool cover -html=coverage.txt -o coverage.html
    - gocover-cobertura < coverage.txt > coverage.xml
    - go tool cover -html coverage.txt -o coverage.html
    # The following line are required for gitlab to detect the covreage based on its regex match.
    # The regex being evaluated by gitlab is: coverage: \d+.\d+% of statements
    - >
      COVERAGE=$(go tool cover -func coverage.txt | grep total: | sed -e "s/\t//g" | sed -n -E 's/^.*\)([0-9]+\.[0-9]+)%$/\1/p')
    - >
      echo "coverage: $(printf '%.1f' "${COVERAGE}")% of statements"
  coverage: /^coverage:\s(\d+(?:\.\d+)?%)/
  artifacts:
    when: always
    name: $CI_JOB_NAME/coverage.txt
    paths:
      - coverage.txt
      - coverage.html
      - coverage.xml
      - junit.xml
    reports:
      coverage_report:
        coverage_format: cobertura
        path: coverage.xml
      junit: junit.xml

test_chart:
  stage: test
  image: devth/helm:latest
  environment:
    action: prepare
    name: staging
  rules:
    - changes:
      - charts/**/*
  script:
    - >
      helm lint
      --set image.repository=$CI_REGISTRY_IMAGE
      --set image.tag=$IMAGE_TAG
      --set gitlab.env=$CI_ENVIRONMENT_SLUG
      --set gitlab.app=$CI_PROJECT_PATH_SLUG
      --set imagePullSecrets[0].name=regcred-kadok
      --set registrySecret.create=true
      --set registrySecret.registry=$CI_REGISTRY
      --set registrySecret.username=$CI_DEPLOY_USER
      --set registrySecret.password=$CI_DEPLOY_PASSWORD
      --set kadok.token=$DISCORD_TOKEN
      charts/kadok

delivery_image:
  stage: delivery
  image:
    name: docker.io/buildah/buildah:latest
  script:
    - podman login --username $CI_REGISTRY_USER --password $CI_REGISTRY_PASSWORD $CI_REGISTRY
    - >
      buildah bud --format docker
      -f $CI_PROJECT_DIR/Dockerfile
      -t $CI_REGISTRY_IMAGE:$IMAGE_TAG
      $CI_PROJECT_DIR
    - buildah push $CI_REGISTRY_IMAGE:$IMAGE_TAG docker://$CI_REGISTRY_IMAGE:$IMAGE_TAG
  after_script:
    - podman logout $CI_REGISTRY

deploy_kadok:
  stage: deploy
  image: devth/helm:latest
  variables:
    KUBE_NAMESPACE: terag-kadok-$KADOK_ENV
  environment:
    name: $KADOK_ENV
  resource_group: $KADOK_ENV
  script:
    - >
      helm upgrade
      --install
      --cleanup-on-fail
      --atomic
      --create-namespace
      --namespace $KUBE_NAMESPACE
      -f $HELM_VALUES
      --set image.repository=$CI_REGISTRY_IMAGE
      --set image.tag=$IMAGE_TAG
      --set gitlab.env=$CI_ENVIRONMENT_SLUG
      --set gitlab.app=$CI_PROJECT_PATH_SLUG
      --set imagePullSecrets[0].name=regcred-kadok
      --set registrySecret.create=true
      --set registrySecret.registry=$CI_REGISTRY
      --set registrySecret.username=$CI_DEPLOY_USER
      --set registrySecret.password=$CI_DEPLOY_PASSWORD
      --set kadok.token=$DISCORD_TOKEN
      kadok-$KADOK_ENV
      charts/kadok
